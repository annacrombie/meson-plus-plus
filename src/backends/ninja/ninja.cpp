// SPDX-license-identifier: Apache-2.0
// Copyright Â© 2021 Intel Corporation

/**
 * Main ninja backend entry point.
 */

#include <cerrno>
#include <filesystem>
#include <fstream>
#include <sys/stat.h>
#include <vector>

#include "entry.hpp"
#include "exceptions.hpp"
#include "toolchains/compiler.hpp"

namespace fs = std::filesystem;

namespace Backends::Ninja {

namespace {

void write_compiler_rule(const std::string & lang,
                         const std::unique_ptr<MIR::Toolchain::Compiler::Compiler> & c,
                         std::ofstream & out) {

    // TODO: build or host correctly
    out << "rule " << lang << "_compiler_for_"
        << "build" << std::endl;

    // Write the command
    // TODO: write the depfile stuff
    out << "  command =";
    for (const auto & c : c->command) {
        out << " " << c;
    }
    out << " ${ARGS}";
    for (const auto & c : c->output_command("${out}")) {
        out << " " << c;
    }
    for (const auto & c : c->compile_only_command()) {
        out << " " << c;
    }
    out << " ${in}" << std::endl;

    // Write the description
    out << "  description = Compiling " << c->language() << " object ${out}" << std::endl
        << std::endl;
}

void write_linker_rule(const std::string & lang,
                       const std::unique_ptr<MIR::Toolchain::Linker::Linker> & c,
                       std::ofstream & out) {

    // TODO: build or host correctly
    out << "rule " << lang << "_linker_for_"
        << "build" << std::endl;

    // Write the command
    // TODO: write the depfile stuff
    out << "  command =";
    for (const auto & c : c->command) {
        out << " " << c;
    }
    out << " ${ARGS}";
    for (const auto & c : c->output_command("${out}")) {
        out << " " << c;
    }
    out << " ${in} ${LINK_ARGS}" << std::endl;

    // Write the description
    out << "  description = Linking target ${out}" << std::endl << std::endl;
}

} // namespace

void generate(const MIR::BasicBlock * const block, const MIR::State::Persistant & pstate) {
    if (!fs::exists(pstate.build_root)) {
        int ret = mkdir(pstate.build_root.c_str(), 0777);
        if (ret != 0) {
            int err = errno;
            if (err != EEXIST) {
                throw Util::Exceptions::MesonException{"Could not create build directory"};
            }
        }
    }

    std::ofstream out{};
    out.open(pstate.build_root / "build.ninja", std::ios::out | std::ios::trunc);
    out << "# This is a build file for the project \"" << pstate.name << "\"." << std::endl
        << "# It is autogenerated by the Meson++ build system." << std::endl
        << "# Do not edit by hand." << std::endl
        << std::endl
        << "ninja_required_version = 1.8.2" << std::endl
        << std::endl;

    out << "# Compilation rules" << std::endl << std::endl;

    for (const auto & [l, tc] : pstate.toolchains) {
        const auto & lstr = MIR::Toolchain::to_string(l);
        // TODO: should also have a _for_host
        write_compiler_rule(lstr, tc.build()->compiler, out);
    }

    out << "# Static Linking rules" << std::endl << std::endl;
    // TODO:

    out << "# Dynamic Linking rules" << std::endl << std::endl;

    for (const auto & [l, tc] : pstate.toolchains) {
        const auto & lstr = MIR::Toolchain::to_string(l);
        // TODO: should also have a _for_host
        write_linker_rule(lstr, tc.build()->linker, out);
    }

    out.flush();
    out.close();
}

} // namespace Backends::Ninja
