// SPDX-license-identifier: Apache-2.0
// Copyright Â© 2021 Intel Corporation

/**
 * Main ninja backend entry point.
 */

#include <filesystem>
#include <fstream>
#include <vector>

#include "entry.hpp"

namespace fs = std::filesystem;

namespace Backends::Ninja {

namespace {

class Rule {
  public:
    Rule(const std::string & n, const std::vector<std::string> & cmd) : name{n}, command{cmd} {};

    const std::string name;
    const std::vector<std::string> command;
};

void write_rules(const std::vector<Rule> & rules, std::ofstream & out) {
    out << "# Compilation rules" << std::endl << std::endl;

    for (const auto & r : rules) {
        out << "rule " << r.name << std::endl;
        out << "  command =";
        for (const auto & c : r.command) {
            out << " " << c;
        }
        out << std::endl;
    }
}

} // namespace

void generate(const MIR::BasicBlock * const block, const MIR::State::Persistant & pstate) {
    std::vector<Rule> rules{};

    for (const auto & [l, tc] : pstate.toolchains) {
        const auto & lstr = MIR::Toolchain::to_string(l);
        // TODO: should also have a _for_host
        Rule rule{lstr + "compiler_for_build", tc.build()->compiler->command};
    }

    if (!fs::exists(pstate.build_root)) {
        
    }

    std::ofstream out{};
    out.open(pstate.build_root / "build.ninja");
    out << "# This is a build file for the project \"" << pstate.name << "\"." << std::endl
        << "# It is autogenerated by the Meson++ build system." << std::endl
        << "# Do not edit by hand." << std::endl
        << std::endl
        << "ninja_required_version = 1.8.2" << std::endl
        << std::endl;
    write_rules(rules, out);
    out.close();
    out.flush();
}

} // namespace Backends::Ninja
